{"meta":{"title":"ZG's Blog","subtitle":null,"description":null,"author":"Zhicheng Gu","url":"http://zcgu.github.io"},"pages":[{"title":"About","date":"2018-12-16T03:58:12.000Z","updated":"2018-12-17T15:58:19.978Z","comments":true,"path":"about/index.html","permalink":"http://zcgu.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"ANR in SharedPreferences","slug":"anr-in-shared-preferences","date":"2018-12-18T07:50:36.000Z","updated":"2018-12-18T07:57:31.103Z","comments":true,"path":"2018/12/17/anr-in-shared-preferences/","link":"","permalink":"http://zcgu.github.io/2018/12/17/anr-in-shared-preferences/","excerpt":"The IssueWhen using SharedPreference you will probably see the following ANRs: 12345678910111213at java.lang.Object.wait(Native Method)- waiting on &lt;&gt;at java.lang.Thread.parkFor(Thread.java:)at sun.misc.Unsafe.park(Unsafe.java:)at java.util.concurrent.locks.LockSupport.park(LockSupport.java:157)at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:813)at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:973)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)at android.app.SharedPreferencesImpl$EditorImpl.run(SharedPreferencesImpl.java:363)at android.app.QueuedWork.waitToFinish(QueuedWork.java:88)at android.app.ActivityThread.handleStopActivity(ActivityThread.java:3948)at android.app.ActivityThread.access$1100(ActivityThread.java:) We can see that main thread is blocking by ActivityThread.handleStopActivity -&gt; QueuedWork.waitToFinish -&gt; SharedPreferencesImpl$EditorImpl.run. By looking at the source code for SharedPreference you will find that the QueueWork is an internal queue used by SharedPreference write operations like apply(). At some points in the app, main thread will wait for all queued write to be done.","text":"The IssueWhen using SharedPreference you will probably see the following ANRs: 12345678910111213at java.lang.Object.wait(Native Method)- waiting on &lt;&gt;at java.lang.Thread.parkFor(Thread.java:)at sun.misc.Unsafe.park(Unsafe.java:)at java.util.concurrent.locks.LockSupport.park(LockSupport.java:157)at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:813)at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:973)at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)at android.app.SharedPreferencesImpl$EditorImpl.run(SharedPreferencesImpl.java:363)at android.app.QueuedWork.waitToFinish(QueuedWork.java:88)at android.app.ActivityThread.handleStopActivity(ActivityThread.java:3948)at android.app.ActivityThread.access$1100(ActivityThread.java:) We can see that main thread is blocking by ActivityThread.handleStopActivity -&gt; QueuedWork.waitToFinish -&gt; SharedPreferencesImpl$EditorImpl.run. By looking at the source code for SharedPreference you will find that the QueueWork is an internal queue used by SharedPreference write operations like apply(). At some points in the app, main thread will wait for all queued write to be done. If the IO on the device is slow enough or there is some work blocking IO, the above ANR will happen. One example of slow IO work is fsync as shown in this StackOverflow thread: 12345678910111213141516171819202122232425262728&quot;pool-1-thread-1&quot; prio=5 tid=10 SUSPENDED| group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41ca62e0 self=0x6034b008| sysTid=4246 nice=0 sched=0/0 cgrp=apps handle=1612996584| state=S schedstat=( 189967314 218846863 555 ) utm=15 stm=3 core=2#00 pc 00021af0 /system/lib/libc.so (__futex_syscall3+8)#01 pc 0000f0b4 /system/lib/libc.so (__pthread_cond_timedwait_relative+48)#02 pc 0000f114 /system/lib/libc.so (__pthread_cond_timedwait+64)#03 pc 000566e7 /system/lib/libdvm.so#04 pc 00056ca9 /system/lib/libdvm.so (dvmChangeStatus(Thread*, ThreadStatus)+34)#05 pc 0005115f /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+406)#06 pc 00029960 /system/lib/libdvm.so#07 pc 00030dec /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)#08 pc 0002e484 /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)#09 pc 000635b9 /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)#10 pc 000635dd /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)#11 pc 000582bb /system/lib/libdvm.so#12 pc 0000d2c0 /system/lib/libc.so (__thread_entry+72)#13 pc 0000d458 /system/lib/libc.so (pthread_create+240)at libcore.io.Posix.fsync(Native Method)at libcore.io.BlockGuardOs.fsync(BlockGuardOs.java:97)at java.io.FileDescriptor.sync(FileDescriptor.java:74)at android.os.FileUtils.sync(FileUtils.java:154)at android.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:597)at android.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)at android.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)at java.lang.Thread.run(Thread.java:841) Here is a detailed explanation of how the codes work in Android N (codes is taken from https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/core/java/android/app/SharedPreferencesImpl.java): Here is how apply() works: 1234567891011121314151617181920212223242526272829303132333435363738394041// File: SharedPreferencesImpl.javapublic void apply() &#123; // This triggers save all changes in this editor to the in memory key-value map. // The return value is a MemoryCommitResult instance that can be used to listen for // when is the disk write done. final MemoryCommitResult mcr = commitToMemory(); // This is a Runnable that waits for the above mcr being written to disk. final Runnable awaitCommit = new Runnable() &#123; public void run() &#123; try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;; // The above Runnable is added to the QueuedWork. // QueueWork is a static queue that stores all apply infos. QueuedWork.add(awaitCommit); // A Runnable that waits for awaitCommit to be done and then remove it from QueuedWork. Runnable postWriteRunnable = new Runnable() &#123; public void run() &#123; awaitCommit.run(); QueuedWork.remove(awaitCommit); &#125; &#125;; // This is the actual places that schedule to write the memory commit result to disk. // It's also provided with the postWriteRunnable which will remove the awaitCommit // Runnable from QueuedWork when the disk write is done. SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it's hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. notifyListeners(mcr);&#125; So what is does is pretty simple: It calls commitToMemory() to commit the changes into memory and uses enqueueDiskWrite() to enqueue the memory changes for a disk write. It also offers QueuedWork a Runnable that can listen for when the disk wrtie is done, and uses a post write Runnable to remove it from QueueWork. For comparasion we can also take a look at commit() method: 123456789101112public boolean commit() &#123; MemoryCommitResult mcr = commitToMemory(); SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */); try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException e) &#123; return false; &#125; notifyListeners(mcr); return mcr.writeToDiskResult;&#125; All it does is commit to memory, write to disk and then wait for the write to finish. Then how does ANR happen? If you take a look at the stack trace at the very beginning it’s actually happening at QueuedWork.waitToFinish(). Here is the code for that, including the comments in the original file: 12345678910111213141516// File: QueuedWork.java/** * Finishes or waits for async operations to complete. * (e.g. SharedPreferences$Editor#startCommit writes) * * Is called from the Activity base class's onPause(), after * BroadcastReceiver's onReceive, after Service command handling, * etc. (so async work is never lost) */public static void waitToFinish() &#123; Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) &#123; toFinish.run(); &#125;&#125; and also 123456789101112// File: ActivityThread.javaprivate void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123; ... // Make sure any pending writes are now committed. if (!r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; ...&#125; The comments is saying that at some places in the application lifecycles, the application will call this method and wait for all runnables in sPendingWorkFinishers to finish. sPendingWorkFinishers contains all awaitCommit runnables that is added by each apply() method, and that means at those checkpoints like Activity.onPause() the app will block on main thread for all async shared preferences write to finish. If by any reasons the disk operation you have takes more than 5 seconds, ANR is triggered. What not clear to me is that why this kind of synchronization can make sure “async work is never lost”. The async writing is always happening on a background thread with or without the blocking of main thread. If the process is getting killed, then the write can’t be done anyway. Also if the system don’t trigger a ANR at those points, the background tasks will likely got more time to finish. How to Fix Write better code. The default implementation of shared preference will read and write the whole xml file every time, so one should avoid storing large data like json or serialized data in the shared preferences. If the app scale is so large and that doesn’t work, there is still ways to don’t let main thread blocked by async writing and avoid this ANR. The possible solution is to use a background commit() instead of apply(), or modify the QueuedWork code to let the wait method return immediately. Note that these approaches somehow violates the original design of shared preference implementation, and should be used in cautions. Don’t use the default implementation of shared preferences. Come up with your implementation or use an alternative. SQLite is not meant for that, but could be an option. There should be other alternatives you can find by a quick search. Even copy and modify the shared preferences code from Android might work, but you need to maintain that code by yourself since then:) NoteNote that this issue is fixed in Android O. TODO: Add references to the code changes.","categories":[{"name":"Android","slug":"Android","permalink":"http://zcgu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zcgu.github.io/tags/Android/"},{"name":"ANR","slug":"ANR","permalink":"http://zcgu.github.io/tags/ANR/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-17T15:58:21.920Z","updated":"2018-12-17T15:58:21.920Z","comments":true,"path":"2018/12/17/hello-world/","link":"","permalink":"http://zcgu.github.io/2018/12/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}