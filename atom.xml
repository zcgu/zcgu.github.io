<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZG&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zcgu.github.io/"/>
  <updated>2018-12-18T07:57:31.103Z</updated>
  <id>http://zcgu.github.io/</id>
  
  <author>
    <name>Zhicheng Gu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ANR in SharedPreferences</title>
    <link href="http://zcgu.github.io/2018/12/17/anr-in-shared-preferences/"/>
    <id>http://zcgu.github.io/2018/12/17/anr-in-shared-preferences/</id>
    <published>2018-12-18T07:50:36.000Z</published>
    <updated>2018-12-18T07:57:31.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Issue"><a href="#The-Issue" class="headerlink" title="The Issue"></a>The Issue</h2><p>When using SharedPreference you will probably see the following ANRs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;&gt;</span><br><span class="line">at java.lang.Thread.parkFor(Thread.java:)</span><br><span class="line">at sun.misc.Unsafe.park(Unsafe.java:)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:157)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:813)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:973)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)</span><br><span class="line">at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)</span><br><span class="line">at android.app.SharedPreferencesImpl$EditorImpl.run(SharedPreferencesImpl.java:363)</span><br><span class="line">at android.app.QueuedWork.waitToFinish(QueuedWork.java:88)</span><br><span class="line">at android.app.ActivityThread.handleStopActivity(ActivityThread.java:3948)</span><br><span class="line">at android.app.ActivityThread.access$1100(ActivityThread.java:)</span><br></pre></td></tr></table></figure><p>We can see that main thread is blocking by <code>ActivityThread.handleStopActivity</code> -&gt; <code>QueuedWork.waitToFinish</code> -&gt; <code>SharedPreferencesImpl$EditorImpl.run</code>. By looking at the source code for SharedPreference you will find that the <code>QueueWork</code> is an internal queue used by SharedPreference write operations like <code>apply()</code>. At some points in the app, main thread will wait for all queued write to be done.</p><a id="more"></a><p>If the IO on the device is slow enough or there is some work blocking IO, the above ANR will happen. One example of slow IO work is fsync as shown in this <a href="https://stackoverflow.com/questions/36905415/how-to-analyze-anr-in-sharedpreferences" target="_blank" rel="noopener">StackOverflow thread</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;pool-1-thread-1&quot; prio=5 tid=10 SUSPENDED</span><br><span class="line">| group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41ca62e0 self=0x6034b008</span><br><span class="line">| sysTid=4246 nice=0 sched=0/0 cgrp=apps handle=1612996584</span><br><span class="line">| state=S schedstat=( 189967314 218846863 555 ) utm=15 stm=3 core=2</span><br><span class="line">#00  pc 00021af0  /system/lib/libc.so (__futex_syscall3+8)</span><br><span class="line">#01  pc 0000f0b4  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)</span><br><span class="line">#02  pc 0000f114  /system/lib/libc.so (__pthread_cond_timedwait+64)</span><br><span class="line">#03  pc 000566e7  /system/lib/libdvm.so</span><br><span class="line">#04  pc 00056ca9  /system/lib/libdvm.so (dvmChangeStatus(Thread*, ThreadStatus)+34)</span><br><span class="line">#05  pc 0005115f  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+406)</span><br><span class="line">#06  pc 00029960  /system/lib/libdvm.so</span><br><span class="line">#07  pc 00030dec  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</span><br><span class="line">#08  pc 0002e484  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</span><br><span class="line">#09  pc 000635b9  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</span><br><span class="line">#10  pc 000635dd  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</span><br><span class="line">#11  pc 000582bb  /system/lib/libdvm.so</span><br><span class="line">#12  pc 0000d2c0  /system/lib/libc.so (__thread_entry+72)</span><br><span class="line">#13  pc 0000d458  /system/lib/libc.so (pthread_create+240)</span><br><span class="line">at libcore.io.Posix.fsync(Native Method)</span><br><span class="line">at libcore.io.BlockGuardOs.fsync(BlockGuardOs.java:97)</span><br><span class="line">at java.io.FileDescriptor.sync(FileDescriptor.java:74)</span><br><span class="line">at android.os.FileUtils.sync(FileUtils.java:154)</span><br><span class="line">at android.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:597)</span><br><span class="line">at android.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)</span><br><span class="line">at android.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</span><br><span class="line">at java.lang.Thread.run(Thread.java:841)</span><br></pre></td></tr></table></figure><p>Here is a detailed explanation of how the codes work in Android N (codes is taken from <a href="https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/core/java/android/app/SharedPreferencesImpl.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/+/nougat-mr1-release/core/java/android/app/SharedPreferencesImpl.java</a>):</p><p>Here is how <code>apply()</code> works:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: SharedPreferencesImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This triggers save all changes in this editor to the in memory key-value map.</span></span><br><span class="line">    <span class="comment">// The return value is a MemoryCommitResult instance that can be used to listen for</span></span><br><span class="line">    <span class="comment">// when is the disk write done.</span></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This is a Runnable that waits for the above mcr being written to disk.</span></span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The above Runnable is added to the QueuedWork.</span></span><br><span class="line">    <span class="comment">// QueueWork is a static queue that stores all apply infos.</span></span><br><span class="line">    QueuedWork.add(awaitCommit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A Runnable that waits for awaitCommit to be done and then remove it from QueuedWork.</span></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.remove(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the actual places that schedule to write the memory commit result to disk.</span></span><br><span class="line">    <span class="comment">// It's also provided with the postWriteRunnable which will remove the awaitCommit</span></span><br><span class="line">    <span class="comment">// Runnable from QueuedWork when the disk write is done.</span></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Okay to notify the listeners before it's hit disk</span></span><br><span class="line">    <span class="comment">// because the listeners should always get the same</span></span><br><span class="line">    <span class="comment">// SharedPreferences instance back, which has the</span></span><br><span class="line">    <span class="comment">// changes reflected in memory.</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So what is does is pretty simple: It calls <code>commitToMemory()</code> to commit the changes into memory and uses <code>enqueueDiskWrite()</code> to enqueue the memory changes for a disk write. It also offers <code>QueuedWork</code> a Runnable that can listen for when the disk wrtie is done, and uses a post write Runnable to remove it from QueueWork.</p><p>For comparasion we can also take a look at <code>commit()</code> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(</span><br><span class="line">mcr, <span class="keyword">null</span> <span class="comment">/* sync write on this thread okay */</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mcr.writtenToDiskLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">notifyListeners(mcr);</span><br><span class="line"><span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All it does is commit to memory, write to disk and then wait for the write to finish.</p><p>Then how does ANR happen? If you take a look at the stack trace at the very beginning it’s actually happening at <code>QueuedWork.waitToFinish()</code>. Here is the code for that, including the comments in the original file:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: QueuedWork.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finishes or waits for async operations to complete.</span></span><br><span class="line"><span class="comment"> * (e.g. SharedPreferences$Editor#startCommit writes)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Is called from the Activity base class's onPause(), after</span></span><br><span class="line"><span class="comment"> * BroadcastReceiver's onReceive, after Service command handling,</span></span><br><span class="line"><span class="comment"> * etc.  (so async work is never lost)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Runnable toFinish;</span><br><span class="line"><span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">toFinish.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and also</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line"><span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">QueuedWork.waitToFinish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The comments is saying that at some places in the application lifecycles, the application will call this method and wait for all runnables in <code>sPendingWorkFinishers</code> to finish. <code>sPendingWorkFinishers</code> contains all <code>awaitCommit</code> runnables that is added by each <code>apply()</code> method, and that means at those checkpoints like <code>Activity.onPause()</code> the app will block on main thread for all async shared preferences write to finish. If by any reasons the disk operation you have takes more than 5 seconds, ANR is triggered.</p><p>What not clear to me is that why this kind of synchronization can make sure “async work is never lost”. The async writing is always happening on a background thread with or without the blocking of main thread. If the process is getting killed, then the write can’t be done anyway. Also if the system don’t trigger a ANR at those points, the background tasks will likely got more time to finish.</p><h2 id="How-to-Fix"><a href="#How-to-Fix" class="headerlink" title="How to Fix"></a>How to Fix</h2><ol><li><p>Write better code. The default implementation of shared preference will read and write the whole xml file every time, so one should avoid storing large data like json or serialized data in the shared preferences. </p></li><li><p>If the app scale is so large and that doesn’t work, there is still ways to don’t let main thread blocked by async writing and avoid this ANR. The possible solution is to use a background <code>commit()</code> instead of <code>apply()</code>, or modify the <code>QueuedWork</code> code to let the wait method return immediately. Note that these approaches somehow violates the original design of shared preference implementation, and should be used in cautions.</p></li><li><p>Don’t use the default implementation of shared preferences. Come up with your implementation or use an alternative. SQLite is not meant for that, but could be an option. There should be other alternatives you can find by a quick search. Even copy and modify the shared preferences code from Android might work, but you need to maintain that code by yourself since then:)</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>Note that this issue is fixed in Android O.</p><blockquote><p>TODO: Add references to the code changes.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-Issue&quot;&gt;&lt;a href=&quot;#The-Issue&quot; class=&quot;headerlink&quot; title=&quot;The Issue&quot;&gt;&lt;/a&gt;The Issue&lt;/h2&gt;&lt;p&gt;When using SharedPreference you will probably see the following ANRs:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;at java.lang.Object.wait(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- waiting on &amp;lt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.lang.Thread.parkFor(Thread.java:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at sun.misc.Unsafe.park(Unsafe.java:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.locks.LockSupport.park(LockSupport.java:157)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:813)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:973)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1281)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:202)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at android.app.SharedPreferencesImpl$EditorImpl.run(SharedPreferencesImpl.java:363)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at android.app.QueuedWork.waitToFinish(QueuedWork.java:88)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at android.app.ActivityThread.handleStopActivity(ActivityThread.java:3948)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at android.app.ActivityThread.access$1100(ActivityThread.java:)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We can see that main thread is blocking by &lt;code&gt;ActivityThread.handleStopActivity&lt;/code&gt; -&amp;gt; &lt;code&gt;QueuedWork.waitToFinish&lt;/code&gt; -&amp;gt; &lt;code&gt;SharedPreferencesImpl$EditorImpl.run&lt;/code&gt;. By looking at the source code for SharedPreference you will find that the &lt;code&gt;QueueWork&lt;/code&gt; is an internal queue used by SharedPreference write operations like &lt;code&gt;apply()&lt;/code&gt;. At some points in the app, main thread will wait for all queued write to be done.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://zcgu.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zcgu.github.io/tags/Android/"/>
    
      <category term="ANR" scheme="http://zcgu.github.io/tags/ANR/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zcgu.github.io/2018/12/17/hello-world/"/>
    <id>http://zcgu.github.io/2018/12/17/hello-world/</id>
    <published>2018-12-17T15:58:21.920Z</published>
    <updated>2018-12-17T15:58:21.920Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
